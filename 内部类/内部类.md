# 内部类

将一个类设计成内部类，我觉得有两方面因素：

1. 在一个类内部，需要操作某种属性，而这个属性需要涉及的面又很广，我们可以考虑，将这些属性设计为内部类。

2. 然后就如下面 [铁心男](https://www.zhihu.com/people/tie-xin-nan) 用户回答的那样，好比你设计类 B 的目的只是为了给类 A 使用，那么，我们就可将其设定为内部类，没有必要将类 B 设置成单独的 Java 文件，防止与其他类产生依赖关系。

然后我们再来说说为什么又将内部类设计为静态内部类与内部类：

1. 首先来看一下静态内部类的特点：如 [昭言](https://www.zhihu.com/people/hujf) 用户所述那样，我是静态内部类，只不过是想借你的外壳用一下。本身来说，我和你没有什么“强依赖”上的关系。没有你，我也可以创建实例。那么，在设计内部类的时候我们就可以做出权衡：如果我内部类与你外部类关系不紧密，耦合程度不高，不需要访问外部类的所有属性或方法，那么我就设计成静态内部类。而且，由于静态内部类与外部类并不会保存相互之间的引用，因此在一定程度上，还会节省那么一点内存资源，何乐而不为呢~~

2. 既然上面已经说了什么时候应该用静态内部类，那么如果你的需求不符合静态内部类所提供的一切好处，你就应该考虑使用内部类了。最大的特点就是：你在内部类中需要访问有关外部类的所有属性及方法，我知晓你的一切... ... 

总结：首先需要知道为什么会有内部类，什么时候应该使用内部类，我们再去讨论，为什么 Java 的设计者们又将内部类设计为静态与非静态，这样就很清晰了。

## 内部类加载时机

无论是静态内部类还是普通内部类，都是在第一次用的时候加载。如果直接访问静态内部类，则外部类不会加载。

## 局部内部类

写在方法或者代码段中的内部类（包括匿名内部类）。

局部内部类为什么只能访问final局部变量，对于成员变量却可以随便访问？

局部变量和成员变量对于内部类而言，具有一定的共性，都是该内部类外面的变量。如果要求内部类只能访问final的局部变量是为了确保局部变量不被修改的话，那么内部类访问成员变量应该也有类似的限制才对

我认为是由于他们的存活范围导致了这个区别：

首先内部类的实例可以在方法结束后依然存活，局部变量在方法结束后却无法存活，所以在内部类中无法访问NON-final的局部变量；

而成员变量的存活时间是取决于外部类的实例的，内部类实例中都会引用当前外部类实例，所以他们拥有一致的生命周期，于是可以访问成员变量。 

剩下的问题是，为什么可以访问final的局部变量呢？

如果将一个访问了final的局部变量的内部类进行反编译，可以发现该变量是被作为构造函数的参数传入进去的，与之一起传入的参数还有外部类实例